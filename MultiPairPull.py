"""
Be advised that this can trigger the Oanda rate limiter, be mindful and adjust your thresholds accordingly.
Comments generated by Doxygen
"""

import requests
import json
import csv
import pandas as pd
from datetime import datetime
import time
import threading

ACCESS_TOKEN = 'your-access-token'  ##< Your OANDA Access Token.
ACCOUNT_ID = 'your-account-id'  ##< Your OANDA Account ID.
MAX_RETRIES = 3  ##< Maximum retries for API calls.

## 
# \brief Load forex pairs from file.
# \return List of forex pairs.
def get_forex_pairs():
    with open('Pairs.txt', 'r') as f:
        pairs = [line.strip() for line in f]
    return pairs

## 
# \brief Fetch historical data from OANDA API.
# \param[in] instrument The instrument for which data will be fetched.
# \param[in] count The number of data points to fetch.
# \param[in] granularity The granularity of the data points.
# \param[in] to The time till when the data should be fetched.
# \return The JSON response from the API call.
def get_historical_data(instrument, count=5000, granularity='M5', to=None):
    url = f"https://api-fxtrade.oanda.com/v3/instruments/{instrument}/candles"

    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {ACCESS_TOKEN}',
    }

    params = {
        'count': count,
        'granularity': granularity,
        'price': 'BA',  # Bid and Ask prices
        'to': to
    }

    for attempt in range(MAX_RETRIES):
        try:
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()  # Will raise an HTTPError if the status is 4xx, 5xx

            return response.json()
        except requests.exceptions.RequestException as e:
            print(f"Error making request: {e}, retrying ({attempt+1}/{MAX_RETRIES})")
            time.sleep(2**attempt)  # exponential backoff
        except Exception as e:
            print(f"Unexpected error occurred: {e}")
            return None

    return None

## 
# \brief Write fetched data to a CSV file.
# \param[in] data The data to be written.
# \param[in] filename The file where the data will be written.
def write_to_csv(data, filename):
    fieldnames = ['time', 'volume', 'bid_open', 'bid_high', 'bid_low', 'bid_close', 'ask_open', 'ask_high', 'ask_low', 'ask_close']
    
    # Check if file already exists
    try:
        with open(filename, 'r') as csvfile:
            pass
    except FileNotFoundError:
        with open(filename, 'w', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()

    # Append new data
    with open(filename, 'a', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        for candle in data['candles']:
            row = {
                'time': candle['time'],
                'volume': candle['volume'],
                'bid_open': candle['bid']['o'],
                'bid_high': candle['bid']['h'],
                'bid_low': candle['bid']['l'],
                'bid_close': candle['bid']['c'],
                'ask_open': candle['ask']['o'],
                'ask_high': candle['ask']['h'],
                'ask_low': candle['ask']['l'],
                'ask_close': candle['ask']['c']
            }
            writer.writerow(row)

## 
# \brief Get the timestamp of the earliest data point in the CSV file.
# \param[in] filename The file from which the timestamp will be extracted.
# \return The timestamp of the earliest data point.
def get_earliest_timestamp(filename):
    try:
        df = pd.read_csv(filename)
        df['time'] = pd.to_datetime(df['time'])
        earliest_time = df['time'].min()
        return earliest_time.isoformat()
    except (FileNotFoundError, pd.errors.EmptyDataError):
        return None

## 
# \brief Fetch data for a given instrument.
# \param[in] instrument The instrument for which data will be fetched.
def fetch_data_for_instrument(instrument):
    filename = f'oanda_data_{instrument}.csv'
    while True:
        try:
            earliest_time = get_earliest_timestamp(filename)
            data = get_historical_data(instrument, to=earliest_time)

            if data is not None and data['candles']:
                write_to_csv(data, filename)
                time.sleep(0.01)  # Introduce delay of 1/100 of a second (10 milliseconds)
            else:
                break  # Stop if no more data or error
        except Exception as e:
            print(f"Unexpected error occurred during data fetching/writing: {e}")

## 
# \brief Main function that initializes the data fetching process.
def main():
    # ... remains the same as in the previous example ...

if __name__ == "__main__":
    main()
